#' Calculate the inverse of a matrix.
#' 
#' @param X a matrix.
#' @return an inverted matrix.
inverse <- function(X) {
  if(require(corpcor)) {
    inv <- corpcor::pseudoinverse(crossprod(X))
  } else if(require(MASS)) {
    inv <- MASS::ginv(X)
  } else {
    inv <- tryCatch(solve(crossprod(X)), error = function(e) e)
    if(class(inv) == "error") {
      stop("Matrix is computationally singular. Please install packages 'MASS' or 'corpcor' for pseudoinverse calculations.")
    }
  }
  
  # Keep column names if they exist
  if(is.null(colnames(inv)) & !is.null(colnames(X))) {
    colnames(inv) <- colnames(X)
    rownames(inv) <- colnames(X)
  }
  inv
}

#' Conley Spatially Correlated Variance-Covariances for Panel Models.
#'
#' This function calculates standard errors for spatially correlated
#' data drawing from \href{https://doi.org/10.1016/S0304-4076(98)00084-0}{Conley (1999)}.
#' Primarily an adaptation of \href{https://github.com/darinchristensen/conley-se}{Darin Christensen}
#' with some changes for package consistency.
#'
#' @import geosphere
#' @export
#'
#' @seealso \code{\link{vcovConley.lm}}, \code{\link{vcovConley.plm}}, 
#'   \code{\link{vcovConley.felm}}, \code{\link{vcovConley.matrix}}
vcovConley <- function(...) { UseMethod("vcovConley") }

#' Conley Spatial Variance-Covariances for matrices.
#' @export 
#' @param model a model object.
#' @param kernel kernel for weights.
#' @param dist_fn distance function.
#' @param dist_cutoff distance for cutoff.
#' @param lat_scale scale.
#' @param verbose verbose output.
#' @return a variance-covariance matrix.
vcovConley.matrix <- function(X, wgts, e, x, y, kernel, dist_fn, dist_cutoff, 
  lat_scale, verbose) {
   
  X_vars <- colnames(X)
  
  # Number of rows and covariates
  n <- nrow(X)
  k <- ncol(X)
  
  # Calculate the distance matrix
  d <- DistMatrix(cbind(x, y), cutoff = dist_cutoff, kernel, dist_fn)
  
  # Spatial correlation matrix
  XeeX <- Bal_XeeXhC(d, X, e, n, k)
  
  # (X'X)^-1
  invXX <- inverse(X) * n
  
  # OLS VCOV
  ee <- crossprod(e)[1,1]
  V_ols <- (ee/(n-k)) * invXX / n
  #V_ols <- vcov(model)
  
  # VCOV with spatial correlation adjustment
  V_spatial <- invXX %*% (XeeX / n) %*% invXX / n
  V_spatial <- (V_spatial + t(V_spatial)) / 2
  
  return(V_spatial)
}


#' Conley Spatial Variance-Covariances for linear model fits.
#' 
#' @export
#' 
#' @param model a model object generated by \code{lm()}.
#' @param x a vector of x spatial coordinates.
#' @param y a vector of y spatial coordinates.
vcovConley.lm <- function(model, x, y, 
                        kernel = "bartlett", dist_fn = "Haversine",
                        dist_cutoff = 500,
                        lat_scale = 111, verbose = FALSE) {
  
  # Get X matrix of covariates
  X <- model.matrix(model)
  wgts <- model$weights
  e <- model$residuals
  
  vcov <- vcovConley.matrix(X, wgts, e, x, y, kernel, dist_fn, dist_cutoff, lat_scale, verbose)
  return(vcov)
}


#' Conley Spatial Variance-Covariances for Panel Models fit with plm.
#' @export
vcovConley.plm <- function(model, x, y,
  kernel = "bartlett", dist_fn = "Haversine",
  dist_cutoff = 500, lag_cutoff = 5,
  lat_scale = 111, verbose = FALSE, cores = 1) {
  
  require(plm)
  if(cores > 1) { invisible(require(parallel)) }
  
  Fac2Num <- function(x) { as.numeric(as.character(x)) }
  
  df <- data.frame(model.matrix(model))
  Xvars <- names(df)
  
  identifiers <- strsplit(rownames(df), "-")
  df$id <- sapply(identifiers, function(i) { i[[1]] })
  df$time <- sapply(identifiers, function(i) { i[[2]] })
  
  df$e <- as.numeric(model$residuals)
  
  df$x <- x # spatial x component
  df$y <- y # spatial y component
  
  # Is it balanced?
  N <- nrow(df)      # number of observations
  n <- length(unique(df$id)) # number of groups
  k <- length(Xvars) # number of covariates
  balanced_pnl <- as.logical(N == n*length(unique(df$time)))
  
  # Empty Matrix:
  XeeX <- matrix(nrow = k, ncol = k, 0)
  
  #================================================================
  # Correct for spatial correlation:
  times <- unique(df[["time"]])
  Ntimes <- length(times)
  
  if(verbose){ message("Starting to loop over time periods...") }
  
  if(balanced_pnl){
    sub_df <- df[df$time == times[1],] 
    y <- sub_df$y
    x <- sub_df$x 
    rm(sub_df)
    
    if(verbose){ message("Computing Distance Matrix...") }
    
    d <- DistMatrix(cbind(x, y), cutoff = dist_cutoff, kernel, dist_fn)
    rm(list = c("x", "y"))
  } else {
    
  }
  
  if(cores == 1) {
    XeeXhs <- lapply(times, function(t) {
      iterateObs(df, Xvars,
                 dist_matrix = d,
                 sub_index = t,
                 type = "spatial",
                 cutoff = dist_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)
    })
  } else {
    XeeXhs <- mclapply(times,function(t) {
      iterateObs(df, Xvars,
                 dist_matrix = d,
                 sub_index = t,
                 type = "spatial",
                 cutoff = dist_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)},
      mc.cores = cores)
  }
  
  if(balanced_pnl){ rm(d) }
  
  # First Reduce:
  XeeX <- Reduce("+",  XeeXhs)
  
  # Generate VCE for only cross-sectional spatial correlation:
  X <- as.matrix(df[, Xvars])
  
  # (X'X)^-1
  invXX <- inverse(X) * n
  
  V_spatial <- invXX %*% (XeeX / n) %*% invXX / n
  V_spatial <- (V_spatial + t(V_spatial)) / 2
  
  if(verbose) {message("Computed Spatial VCOV.")}
  
  #================================================================
  # Correct for serial correlation:
  ids <- unique(df$id)
  Nids <- length(ids)
  
  if(verbose){ message("Starting to loop over ids...") }
  
  if(cores == 1) {
    XeeXhs <- lapply(ids, function(i) {
      iterateObs(df, Xvars,
                 sub_index = i,
                 type = "serial",
                 cutoff = lag_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)
    })
  } else {
    XeeXhs <- mclapply(ids,function(i) {
      iterateObs(df, Xvars,
                 sub_index = i,
                 type = "serial",
                 cutoff = lag_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)},
      mc.cores = cores)
  }
  
  XeeX_serial <- Reduce("+",  XeeXhs)
  
  XeeX <- XeeX + XeeX_serial
  
  V_spatial_HAC <- invXX %*% (XeeX / n) %*% invXX / n
  V_spatial_HAC <- (V_spatial_HAC + t(V_spatial_HAC)) / 2
  
  return_list <- list(
    "OLS" = vcv,
    "Spatial" = V_spatial,
    "Spatial_HAC" = V_spatial_HAC)
  
  return(return_list)
  
}

#' Conley Spatial Variance-Covariances for Fixed Effects models fit with lfe.
#' 
#' @export
#' 
#' @param id_var character indicating individual variable
#' @param time_var character indicating time variable
#' @param x_var character name of variable of the x-axis (longitude)
#' @param y_var character name of variable of the y-axis (latitude)
#' @param lag_cutoff lag of cutoff
#' @param balanced_pnl logical for whether balanced panel
#' @param cores number of cores to use
vcovConley.felm <- function(model,
                     id_var, time_var, x_var, y_var,
                     kernel = "bartlett", dist_fn = "Haversine",
                     dist_cutoff = 500, lag_cutoff = 5,
                     lat_scale = 111, verbose = FALSE, cores = 1,
                     balanced_pnl = FALSE) {
  
  require(lfe)
  
  Fac2Num <- function(x) { as.numeric(as.character(x)) }
  
  if(cores > 1) { invisible(require(parallel)) }

  Xvars <- colnames(model$cX)
  df <- data.frame(model$cX)
  names(df) <- c(Xvars)
  
  for(v in names(model$fe)) {
    df[[v]] <- Fac2Num(model$fe[[v]]) 
  }
  for(v in names(model$clustervar)) {
    df[[v]] <- Fac2Num(model$clustervar[[v]]) 
  }
  df$e <- as.numeric(model$residuals)
  vcv <- model$vcv
  
  n <- nrow(df)      # number of observations
  k <- length(Xvars) # number of covariates
 
  # Deal with time and id variables
  if(missing(id_var)) { df$id <- 1; id_var <- "id" }
  if(missing(time_var)) { df$time <- 1; time_var <- "time" }
  df <- df[, c(Xvars, id_var, time_var, x_var, y_var, "e")]
  names(df) <- c(Xvars, "id", "time", "x", "y", "e")

  # Empty Matrix:
  XeeX <- matrix(nrow = k, ncol = k, 0)
  
  #================================================================
  # Correct for spatial correlation:
  times <- unique(df[["time"]])
  Ntimes <- length(times)
  
  if(verbose){ message("Starting to loop over time periods...") }
  
  if(balanced_pnl){
    sub_df <- df[df$time == times[1],] 
    y <- sub_df$y
    x <- sub_df$x 
    rm(sub_df)
    
    if(verbose){ message("Computing Distance Matrix...") }
    
    d <- DistMatrix(cbind(x, y), cutoff = dist_cutoff, kernel, dist_fn)
    rm(list = c("x", "y"))
  } else {
    
  }
  
  if(cores == 1) {
    XeeXhs <- lapply(times, function(t) {
      iterateObs(df, Xvars,
                 dist_matrix = d,
                 sub_index = t,
                 type = "spatial",
                 cutoff = dist_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)
    })
  } else {
    XeeXhs <- mclapply(times,function(t) {
      iterateObs(df, Xvars,
                 dist_matrix = d,
                 sub_index = t,
                 type = "spatial",
                 cutoff = dist_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)},
      mc.cores = cores)
  }
  
  if(balanced_pnl){ rm(d) }
  
  # First Reduce:
  XeeX <- Reduce("+",  XeeXhs)
  
  # Generate VCE for only cross-sectional spatial correlation:
  X <- as.matrix(df[, Xvars])
  
  # (X'X)^-1
  invXX <- inverse(X) * n
  
  V_spatial <- invXX %*% (XeeX / n) %*% invXX / n
  V_spatial <- (V_spatial + t(V_spatial)) / 2
  
  if(verbose) {message("Computed Spatial VCOV.")}
  
  #================================================================
  # Correct for serial correlation:
  ids <- unique(df$id)
  Nids <- length(ids)
  
  if(verbose){ message("Starting to loop over ids...") }
  
  if(cores == 1) {
    XeeXhs <- lapply(ids, function(i) {
      iterateObs(df, Xvars,
                 sub_index = i,
                 type = "serial",
                 cutoff = lag_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)
    })
  } else {
    XeeXhs <- mclapply(ids,function(i) {
      iterateObs(df, Xvars,
                 sub_index = i,
                 type = "serial",
                 cutoff = lag_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)},
      mc.cores = cores)
  }
  
  XeeX_serial <- Reduce("+",  XeeXhs)
  
  XeeX <- XeeX + XeeX_serial
  
  V_spatial_HAC <- invXX %*% (XeeX / n) %*% invXX / n
  V_spatial_HAC <- (V_spatial_HAC + t(V_spatial_HAC)) / 2
  
  return_list <- list(
    "OLS" = vcv,
    "Spatial" = V_spatial,
    "Spatial_HAC" = V_spatial_HAC)
  
  return(return_list)
}


#' Iterate observations
iterateObs <- function(df, Xvars, dist_matrix, sub_index, type, cutoff, balanced_pnl,
                       verbose, kernel, dist_fn) {
  k <- length(Xvars)
  
  
  if(type == "spatial") {
    sub_df <- df[df$time == sub_index,]
    n1 <- nrow(sub_df)
    if(n1 > 1000 & verbose){ message(paste("Starting on sub index:", sub_index)) }
    
    X <- as.matrix(sub_df[, Xvars])
    e <- sub_df$e
    
    if(balanced_pnl) {
      XeeXhs <- Bal_XeeXhC(dist_matrix, X, e, n1, k)
    } else {
      # If n1 >= 50k obs, then avoiding construction of distance matrix.
      # This requires more operations, but is less memory intensive.
      if(n1 < 5 * 10^4) {
        XeeXhs <- XeeXhC(cbind(sub_df$y, sub_df$x), cutoff, X, e, n1, k,
                         kernel, dist_fn)
      } else {
        XeeXhs <- XeeXhC_Lg(cbind(sub_df$y, sub_df$x), cutoff, X, e, n1, k,
                            kernel, dist_fn)
      }
    }
  } else if(type == "serial") {
    sub_df <- df[df$id == sub_index,]
    n1 <- nrow(sub_df)
    if(n1 > 1000 & verbose){ message(paste("Starting on sub index:", sub_index)) }
    
    X <- as.matrix(sub_df[, Xvars])
    e <- sub_df$e
    times <- as.numeric(sub_df$time)
    
    XeeXhs <- TimeDist(times, cutoff, X, e, n1, k)
  }
  
  XeeXhs
}
