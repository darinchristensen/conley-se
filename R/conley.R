#' Calculate the inverse of a matrix.
#' 
#' @param X a matrix.
#' @return an inverted matrix.
inverse <- function(X) {
  if(require(corpcor)) {
    inv <- corpcor::pseudoinverse(crossprod(X))
  } else if(require(MASS)) {
    inv <- MASS::ginv(X)
  } else {
    inv <- tryCatch(solve(crossprod(X)), error = function(e) e)
    if(class(inv) == "error") {
      stop("Matrix is computationally singular. Please install packages 'MASS' or 'corpcor' for pseudoinverse calculations.")
    }
  }
  
  # Keep column names if they exist
  if(is.null(colnames(inv)) & !is.null(colnames(X))) {
    colnames(inv) <- colnames(X)
    rownames(inv) <- colnames(X)
  }
  inv
}

#' Calculate Conley Standard Errors for cross-sectional data.
#'
#' This function calculates standard errors for spatially correlated
#' data drawing from \href{https://doi.org/10.1016/S0304-4076(98)00084-0}{Conley (1999)}.
#' Primarily an adaptation of \href{https://github.com/darinchristensen/conley-se}{Darin Christensen}
#' with some changes for package consistency.
#'
#' @import geosphere
#' @export
#'
#' @param model a model object
#' @param kernel kernel for weights
#' @param dist_fn distance function
#' @param dist_cutoff distance for cutoff
#' @param lat_scale scale
#' @param verbose verbose output
#' @return a variance-covariance matrix
ConleySE <- function(...) { UseMethod("ConleySE") }


#' @export 
ConleySE.matrix <- function(X) {}


#' Calculate spatially correlated variance-covariance matrix from a lm object.
#' 
#' @export
#' 
#' @param model a model object generated by \code{lm()}.
#' @param x a vector of x spatial coordinates.
#' @param y a vector of y spatial coordinates.
ConleySE.lm <- function(model, x, y, 
                        kernel = "bartlett", dist_fn = "Haversine",
                        dist_cutoff = 500,
                        lat_scale = 111, verbose = FALSE) {
  
  # Get X matrix of covariates
  X <- model.matrix(model)
  X_vars <- colnames(X)
  wgts <- model$weights
  e <- model$residuals
  
  # Number of rows and covariates
  n <- nrow(X)
  k <- ncol(X)
  
  # Calculate the distance matrix
  d <- DistMat(cbind(y, x), cutoff = dist_cutoff, kernel, dist_fn)
  
  # Spatial correlation matrix
  XeeX <- Bal_XeeXhC(d, X, e, n, k)
  
  # (X'X)^-1
  invXX <- inverse(X) * n
  
  # OLS VCOV
  ee <- crossprod(e)[1,1]
  #V_ols <- (ee/(n-k)) * invXX / n
  V_ols <- vcov(model)
  
  # VCOV with spatial correlation adjustment
  V_spatial <- invXX %*% (XeeX / n) %*% invXX / n
  V_spatial <- (V_spatial + t(V_spatial)) / 2
  
  return(V_spatial)
}

#' @export
ConleySE.plm <- function(model) {
  return(1)
}

#' Calculate a spatially correlated variance-covariance matrix from a felm object.
#' @export
#' 
#' @param id_var character indicating individual variable
#' @param time_var character indicating time variable
#' @param x_var character name of variable of the x-axis (longitude)
#' @param y_var character name of variable of the y-axis (latitude)
#' @param lag_cutoff lag of cutoff
#' @param balanced_pnl logical for whether balanced panel
#' @param cores number of cores to use
ConleySE.felm <- function(model,
                     id_var, time_var, x_var, y_var,
                     kernel = "bartlett", dist_fn = "Haversine",
                     dist_cutoff = 500, lag_cutoff = 5,
                     lat_scale = 111, verbose = FALSE, cores = 1,
                     balanced_pnl = FALSE) {
  
  require(lfe)
  
  Fac2Num <- function(x) { as.numeric(as.character(x)) }
  
  if(cores > 1) { invisible(require(parallel)) }

  Yvars <- colnames(model$cY) 
  Xvars <- colnames(model$cX)
  df <- data.frame(model$cY, 
                  model$cX)
  names(df) <- c(Yvars, Xvars)
  
  for(v in names(model$fe)) {
    df[[v]] <- Fac2Num(model$fe[[v]]) 
  }
  for(v in names(model$clustervar)) {
    df[[v]] <- Fac2Num(model$clustervar[[v]]) 
  }
  df$e <- as.numeric(model$residuals)
  vcv <- model$vcv
  
  n <- nrow(df)      # number of observations
  k <- length(Xvars) # number of covariates
 
  # Deal with time and id variables
  if(missing(id_var)) { df$id <- 1; id_var <- "id" }
  if(missing(time_var)) { df$time <- 1; time_var <- "time" }
  df <- df[, c(Yvars, Xvars, id_var, time_var, x_var, y_var, "e")]
  names(df) <- c(Yvars, Xvars, "id", "time", "x", "y", "e")

  # Empty Matrix:
  XeeX <- matrix(nrow = k, ncol = k, 0)
  
  #================================================================
  # Correct for spatial correlation:
  times <- unique(df[["time"]])
  Ntimes <- length(times)
  
  if(verbose){ message("Starting to loop over time periods...") }
  
  if(balanced_pnl){
    sub_df <- df[df$time == times[1],] 
    y <- sub_df$y
    x <- sub_df$x 
    rm(sub_df)
    
    if(verbose){ message("Computing Distance Matrix...") }
    
    d <- DistMat(cbind(y, x), cutoff = dist_cutoff, kernel, dist_fn)
    rm(list = c("y", "x"))
  } else {
    
  }
  
  if(cores == 1) {
    XeeXhs <- lapply(times, function(t) {
      iterateObs(df, Xvars,
                 dist_matrix = d,
                 sub_index = t,
                 type = "spatial",
                 cutoff = dist_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)
    })
  } else {
    XeeXhs <- mclapply(times,function(t) {
      iterateObs(df, Xvars,
                 dist_matrix = d,
                 sub_index = t,
                 type = "spatial",
                 cutoff = dist_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)},
      mc.cores = cores)
  }
  
  if(balanced_pnl){ rm(d) }
  
  # First Reduce:
  XeeX <- Reduce("+",  XeeXhs)
  
  # Generate VCE for only cross-sectional spatial correlation:
  X <- as.matrix(df[, Xvars])
  
  # (X'X)^-1
  invXX <- inverse(X) * n
  
  V_spatial <- invXX %*% (XeeX / n) %*% invXX / n
  V_spatial <- (V_spatial + t(V_spatial)) / 2
  
  if(verbose) {message("Computed Spatial VCOV.")}
  
  #================================================================
  # Correct for serial correlation:
  ids <- unique(df$id)
  Nids <- length(ids)
  
  if(verbose){ message("Starting to loop over ids...") }
  
  if(cores == 1) {
    XeeXhs <- lapply(ids, function(i) {
      iterateObs(df, Xvars,
                 sub_index = i,
                 type = "serial",
                 cutoff = lag_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)
    })
  } else {
    XeeXhs <- mclapply(ids,function(i) {
      iterateObs(df, Xvars,
                 sub_index = i,
                 type = "serial",
                 cutoff = lag_cutoff,
                 balanced_pnl = balanced_pnl,
                 kernel = kernel,
                 dist_fn = dist_fn,
                 verbose = verbose)},
      mc.cores = cores)
  }
  
  XeeX_serial <- Reduce("+",  XeeXhs)
  
  XeeX <- XeeX + XeeX_serial
  
  V_spatial_HAC <- invXX %*% (XeeX / n) %*% invXX / n
  V_spatial_HAC <- (V_spatial_HAC + t(V_spatial_HAC)) / 2
  
  return_list <- list(
    "OLS" = vcv,
    "Spatial" = V_spatial,
    "Spatial_HAC" = V_spatial_HAC)
  
  return(return_list)
}


#' Iterate observations
iterateObs <- function(df, Xvars, dist_matrix, sub_index, type, cutoff, balanced_pnl,
                       verbose, kernel, dist_fn) {
  k <- length(Xvars)
  
  
  if(type == "spatial") {
    sub_df <- df[df$time == sub_index,]
    n1 <- nrow(sub_df)
    if(n1 > 1000 & verbose){ message(paste("Starting on sub index:", sub_index)) }
    
    X <- as.matrix(sub_df[, Xvars])
    e <- sub_df$e
    
    if(balanced_pnl) {
      XeeXhs <- Bal_XeeXhC(dist_matrix, X, e, n1, k)
    } else {
      # If n1 >= 50k obs, then avoiding construction of distance matrix.
      # This requires more operations, but is less memory intensive.
      if(n1 < 5 * 10^4) {
        XeeXhs <- XeeXhC(cbind(sub_df$y, sub_df$x), cutoff, X, e, n1, k,
                         kernel, dist_fn)
      } else {
        XeeXhs <- XeeXhC_Lg(cbind(sub_df$y, sub_df$x), cutoff, X, e, n1, k,
                            kernel, dist_fn)
      }
    }
  } else if(type == "serial") {
    sub_df <- df[df$id == sub_index,]
    n1 <- nrow(sub_df)
    if(n1 > 1000 & verbose){ message(paste("Starting on sub index:", sub_index)) }
    
    X <- as.matrix(sub_df[, Xvars])
    e <- sub_df$e
    times <- sub_df$time
    
    XeeXhs <- TimeDist(times, cutoff, X, e, n1, k)
  }
  
  XeeXhs
}
